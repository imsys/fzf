#     ____      ____
#    / __/___  / __/
#   / /_/_  / / /_
#  / __/ / /_/ __/
# /_/   /___/_/ completion.nu


# Generated by AI, mostly Gemini.

# Translates the core logic of fzf's completion.zsh/bash to Nushell.

# --- Default Environment Variables ---
# These can be overridden in your config.nu or environment.
# Example: $env.FZF_COMPLETION_TRIGGER = "!<TAB>"

# Set default height for fzf-tmux pane. e.g. '40%'
$env.FZF_TMUX_HEIGHT = $env.FZF_TMUX_HEIGHT? | default '40%'
# Options for fzf-tmux wrapper. e.g. '--paneid popup'
$env.FZF_TMUX_OPTS = $env.FZF_TMUX_OPTS? | default ''
# Trigger sequence. e.g. '**'
$env.FZF_COMPLETION_TRIGGER = $env.FZF_COMPLETION_TRIGGER? | default '**'
# Options for fzf completion in general. e.g. '--border'
$env.FZF_COMPLETION_OPTS = $env.FZF_COMPLETION_OPTS? | default ''
# Options specific to path completion. e.g. '--extended'
$env.FZF_COMPLETION_PATH_OPTS = $env.FZF_COMPLETION_PATH_OPTS? | default ''
# Options specific to directory completion. e.g. '--extended'
$env.FZF_COMPLETION_DIR_OPTS = $env.FZF_COMPLETION_DIR_OPTS? | default ''

# --- Helper Functions ---

# Helper to build default fzf options list
def __fzf_defaults_nu [prepend: string, append: string] {
  let default_opts = $env.FZF_DEFAULT_OPTS? | default ''
  let default_opts_file = $env.FZF_DEFAULT_OPTS_FILE? | default ''

  let file_opts = try {
     open $default_opts_file | lines | str trim | where not ($in | is-empty)
  } catch {
     [] # Return empty list on error (e.g., file not found)
  }

  # Build options list
  [$"--height" ($env.FZF_TMUX_HEIGHT? | default '40%') $prepend]
  | append $file_opts # Append options from file
  | append ($default_opts | split words | where not ($in | is-empty)) # Append options from $FZF_DEFAULT_OPTS
  | append ($append | split words | where not ($in | is-empty)) # Append options from function argument
  | where {|it|
      try {
        # Check if it's a string and not empty. If this fails for an item (e.g., error),
        # the catch block handles it.
        ($it | is-string) and not ($it | is-empty)
      } catch {
        # If any error occurred when processing this item (like trying to call is-string on an error),
        # return false to filter it out.
        false
      }
    } # Filter to keep only non-empty strings, safely handling potential errors
}

# Wrapper for running fzf or fzf-tmux
def __fzf_comprun_nu [
  context_name: string, # e.g., "fzf-completion", "fzf-helper" - mainly for potential debugging
  query: string,        # The initial query string for fzf
  ...fzf_opts: string # Remaining options for fzf/fzf-tmux
  ] {
  # Check for custom comprun function (Nu equivalent)
  if ((help commands | where name == '_fzf_comprun_nu') | is-not-empty) {
    # Note: Nushell doesn't have a direct equivalent to Zsh/Bash `type -t _fzf_comprun`.
    # This check assumes a user might define a custom command named `_fzf_comprun_nu`.
    _fzf_comprun_nu $context_name $query ...$fzf_opts # Pass args correctly to custom function
  } else if ($env.TMUX_PANE? | is-not-empty) and (($env.FZF_TMUX? | default 0) != 0 or ($env.FZF_TMUX_OPTS? | is-not-empty)) {
    # Running inside tmux, use fzf-tmux
    # Skip the first arg which is cmd_word (passed for context but not needed by fzf/fzf-tmux itself)
    let final_fzf_opts = ['--query', $query] | append $fzf_opts

    if ($env.FZF_TMUX_OPTS? | is-not-empty) {
      # If FZF_TMUX_OPTS contains multiple options as a single string, split them.
      let tmux_opts_list = $env.FZF_TMUX_OPTS | split words
      fzf-tmux ...$tmux_opts_list -- ...$final_fzf_opts
    } else {
      fzf-tmux -d $env.FZF_TMUX_HEIGHT -- ...$final_fzf_opts
    }
  } else {
    # Not in tmux or not configured for fzf-tmux, use fzf directly
    let final_fzf_opts = ['--query', $query] | append $fzf_opts
    fzf ...$final_fzf_opts
  }
}

# Generate host list for ssh/telnet
def __fzf_list_hosts_nu [] {
  # Translate the Zsh pipeline using Nu commands and external tools
  let ssh_configs = try { open ~/.ssh/config | lines } catch { [] }
  let ssh_configs_d = try { open ~/.ssh/config.d/* | lines } catch { [] }
  let ssh_config_global = try { open /etc/ssh/ssh_config | lines } catch { [] }
  let known_hosts = try { open ~/.ssh/known_hosts | lines } catch { [] }
  let hosts_file = try { open /etc/hosts | lines } catch { [] }

  [
    (
      # Process ssh config files
      $ssh_configs | append $ssh_configs_d | append $ssh_config_global
      | where {|it| ($it | str downcase | str starts-with 'host') or ($it | str downcase | str starts-with 'hostname') }
      | parse --regex '^\s*host(?:name)?\s+(?<hosts>.+)' # Extract hosts after keyword
      | default { hosts: null } # Handle lines that don't match regex
      | get hosts
      | where $in != null
      | split words
      | where not ($in =~ '[*?%]') # Exclude patterns containing *, ?, or %
    )
    (
      # Process known_hosts file
      $known_hosts
      | parse --regex '^(?:\[)?(?<hosts>[a-z0-9.,:_-]+)' # Extract hostnames (possibly in [], possibly comma-separated) - added underscore
      | default { hosts: null }
      | get hosts
      | where $in != null
      | each { |it| $it | split row ',' } # Split comma-separated hosts if any
      | flatten
    )
    (
      # Process /etc/hosts file
      $hosts_file
      | where { |it| not ($it | str starts-with '#') } # Ignore comments
      | where { |it| not ($it | str trim | is-empty) } # Ignore empty lines
      | where { |it| not ($it | str contains '0.0.0.0') } # Ignore 0.0.0.0
      | str replace --regex '#.*$' '' # Remove trailing comments
      | parse --regex '^\s*\S+\s+(?<hosts>.+)' # Extract hosts part (after IP)
      | default { hosts: null }
      | get hosts
      | where $in != null
      | split words # Split multiple hosts on the same line
    )
  ]
  | flatten # Combine all lists into a single stream
  | where not ($in | is-empty) # Remove empty entries
  | sort | uniq # Sort and remove duplicates
}


# Base function for path/directory completion
def __fzf_generic_path_completion_nu [
    prefix: string,           # The text before the trigger
    compgen_cmd_name: string,        # Optional custom generator block `{|dir| ... }`
    fzf_opts_nu: list<string>, # Extra options for fzf
    suffix: string,           # Suffix to add to selection (e.g., "/")
    _tail: string             # Trailing chars (e.g., space, often handled by insertion logic now)
] {
  let base = $prefix
  # Note: Zsh `eval "base=$base"` handles complex expansions like `$(...)`.
  # Nushell doesn't evaluate arbitrary strings in the same way. We assume `prefix`
  # We assume `prefix` is a simple path prefix. Expand leading ~ if present.
  let base_expanded: string = $base | path expand --no-symlink # Expand ~ but don't resolve symlinks yet

  # Determine the directory to search within
  let dir: string = if ($base_expanded | path type) == 'dir' {
    $base_expanded
  } else if ($base_expanded | str contains (char separator)) { # Use platform separator
    $base_expanded | path dirname
  } else {
     '.'
  }

  # Find the deepest existing directory part of the path to use as root for find/ls
  let root_dir = $dir
  # Use path expand to normalize and handle .., ., etc.
  let root_dir_expanded: string = $dir | path expand # Resolve fully now, including symlinks by default

  # Simplified logic: Use the determined 'dir'. Zsh has a loop to find existing parents.
  # Nushell's `find` or `ls` might handle non-existent paths gracefully or error.
  # Let's try with the derived dir, using path expand for clarity.


  # Calculate leftover part (what the user typed after the last slash)
  let leftover = if $root_dir == '.' {
    $base # If base didn't contain '/', leftover is the whole base
  } else {
    # Ensure root_dir_expanded has a trailing slash for correct replacement
    let root_to_replace: string = if ($root_dir_expanded | str ends-with (char separator)) { $root_dir_expanded } else { $"($root_dir_expanded)(char separator)" }
    # Use the ~ expanded base for replacement
    $base_expanded | str replace $root_to_replace ''
  }

  # --- Candidate Generation ---
  # Use the custom generator if provided, otherwise use external `find`.
  let generation_result = if not ($compgen_cmd_name | is-empty) {
    # Construct the command call as a list and execute using the spread operator
    let command_call = [$compgen_cmd_name, $root_dir_expanded]
    let custom_candidates = try {
        ...$command_call # Execute the command with its argument
    } catch {
        print -e $"Error executing custom compgen command '($compgen_cmd_name)' with arg '($root_dir_expanded)'"
        [] # Return empty list on error
    }
    { candidates: $custom_candidates, use_walker: false } # Return record
  } else {
    { candidates: [], use_walker: true } # Return record
  }

  let candidates = $generation_result.candidates
  let use_walker: bool = $generation_result.use_walker

  # --- Run FZF ---
  let fzf_default_opts = (__fzf_defaults_nu "--reverse --scheme=path" ($env.FZF_COMPLETION_OPTS | default ''))
  # Add completion-type specific options
  let completion_type_opts = if $suffix == '/' {
      $env.FZF_COMPLETION_DIR_OPTS? | default '' | split words
  } else {
      $env.FZF_COMPLETION_PATH_OPTS? | default '' | split words
  }

  mut fzf_all_opts = $fzf_default_opts | append $fzf_opts_nu | append $completion_type_opts

  # If using the walker, add walker options
  if $use_walker {
    let walker_type = if ($suffix == '/') {
        # Directory completion: find only directories, follow links
        "dir,follow"
    } else {
        # Path completion: find files, dirs, links, follow links, include hidden
        "file,dir,follow,hidden"
    }
    # Add walker options
    $fzf_all_opts = $fzf_all_opts | append ["--walker", $walker_type, "--walker-root", $root_dir_expanded]
  }

  # Pipe candidates (if any) to fzf or let fzf use its walker
  let fzf_selection = if $use_walker {
      # No input pipe, fzf uses walker
      __fzf_comprun_nu "fzf-path-completion-walker" $leftover ...$fzf_all_opts
  } else {
      # Pipe custom candidates
      $candidates | __fzf_comprun_nu "fzf-path-completion-custom" $leftover ...$fzf_all_opts
  } | str trim # fzf output often has trailing newline

  # --- Format Selection ---
  let completed_item = if ($fzf_selection | is-not-empty) {
      # Add suffix (e.g., "/" for directories)
      $fzf_selection + $suffix
  } else {
      "" # No selection
  }

  # --- Return Result ---
  # Nushell completers return a list of completion strings.
  if ($completed_item | is-not-empty) {
     [$completed_item] # Return selection as a list containing one item
  } else {
     [] # Return empty list if no selection
  }
}

# Specific path completion wrapper
def _fzf_path_completion_nu [prefix: string] {
  # Zsh args: base, lbuf, _fzf_compgen_path, "-m", "", " "
  # Nu: prefix, empty command name (use find), ["-m"], "", " "
  __fzf_generic_path_completion_nu $prefix "" ["-m"] "" " "
}

# Specific directory completion wrapper
def _fzf_dir_completion_nu [prefix: string] {
  # Zsh args: base, lbuf, _fzf_compgen_dir, "", "/", ""
  # Nu: prefix, empty command name (use find), [], "/", ""
  __fzf_generic_path_completion_nu $prefix "" [] "/" ""
}

# General completion helper for commands that feed a list to fzf
def _fzf_complete_nu [
    data_gen_closure: closure,    # Name of command that generates candidates
    fzf_opts: list<string>,  # Extra options for fzf (like -m, +m)
    post_process_closure: closure # Name of command to process the selected item (optional)
] {
  # Build fzf default options list
  let fzf_default_opts = (__fzf_defaults_nu "--reverse" ($env.FZF_COMPLETION_OPTS | default ''))

  # Capture prefix from environment (set by the key binding handler)
  let prefix = $env.FZF_CURRENT_PREFIX? | default ''

  # Generate candidates using the provided command
  let candidates = try {
    #run-external $data_gen_cmd # Changed: Execute external command
    $data_gen_closure
  } catch {
    print -e $"Error executing data_gen closure: ($data_gen_closure)"
    []
  }

  # Run fzf and get selection
  let fzf_selection = $candidates
  | __fzf_comprun_nu "fzf-helper" $prefix ...$fzf_default_opts ...$fzf_opts # Pass context name, query, and options
  | str trim # Trim potential trailing newline from fzf

  # Apply post-processing if closure provided and selection is not empty
  # Check if optional closure is present ($nothing is the default for omitted optional args)
  let processed_selection = if ($fzf_selection | is-not-empty) and ($post_process_closure != null) {
  # Call the post-processing closure with the selection
  try {
      do $post_process_closure $fzf_selection
    } catch {
      print -e $"Error executing post_process closure: ($post_process_closure)"
      $fzf_selection # Return original selection on error
    }
  } else {
    $fzf_selection
  }

  if not ($processed_selection | is-empty) {
    [$processed_selection]
  } else {
    []
  }

}

# SSH/Telnet completion
def _fzf_complete_ssh_nu [prefix: string, input_line_before_trigger: string] {
  let words = ($input_line_before_trigger | split words)
  let word_count = $words | length

  # Find the index of the word being completed (which is the prefix)
  # If prefix is empty, completion happens after a space, index is word_count
  # If prefix is not empty, it's the last word, index is word_count - 1
  let completion_index = if ($prefix | is-empty) { $word_count } else { $word_count - 1 }

  mut handled = false
  mut completion_result = [] # List of completion strings to return

  # Check for -i, -F, -E flags immediately preceding the cursor position
  if $completion_index > 0 {
    let prev_arg = ($words | get ($completion_index - 1))
    if ($prev_arg in ['-i', '-F', '-E']) {
      $handled = true
      # Call path completion with the current prefix
      $completion_result = (_fzf_path_completion_nu $prefix)
    }
  }

  # If not handled by path completion, do host completion
  if not $handled {
    let user_prefix = if ($prefix | str contains "@") { ($prefix | split column "@" | first) + "@" } else { "" }

    let host_candidates_gen = {||
      __fzf_list_hosts_nu
      | each {|host_item| $user_prefix + $host_item } # Prepend user@ if present in prefix
    }

    # Zsh options: +m -- ; Nu: pass ["+m"]
    let selected_host = (_fzf_complete_nu $host_candidates_gen ["+m"] {}) # No post-processing needed here
    if not ($selected_host | is-empty) {
      $completion_result = [$selected_host]
    }
  }

  $completion_result
}

# Export completion
def _fzf_complete_export_nu [prefix: string] {
  let vars_gen_closure = {|| env | get name } # Nushell `env` provides names directly
  # Zsh options: -m -- ; Nu: pass ["-m"]
  _fzf_complete_nu $vars_gen_closure ["-m"] {}
}

# Unset completion (same as export)
def _fzf_complete_unset_nu [prefix: string] {
  _fzf_complete_export_nu $prefix # Re-use export logic
}

# Unalias completion
def _fzf_complete_unalias_nu [prefix: string] {
  let aliases_gen_closure = {|| aliases | get alias } # Use 'alias' column from `aliases` command
  # Zsh options: +m -- ; Nu: pass ["+m"]
  _fzf_complete_nu $aliases_gen_closure ["+m"] {}
}

# Kill completion post-processor (extracts PID)
def _fzf_complete_kill_post_nu [selected_line: string] {
  # Assuming standard ps output where PID is the second column
  $selected_line | split words | get 1 | default ""
}

# Kill completion
def _fzf_complete_kill_nu [prefix: string] {
  let ps_gen_closure = {|| # Define ps generator as a closure
    # Try standard ps, then busybox, then cygwin format approximation
    # Use `^ps` to ensure external command execution
    try {
      ^ps -eo user,pid,ppid,start,time,command | lines # Keep header for --header-lines=1
    } catch {
      try {
        ^ps -eo user,pid,ppid,time,args | lines # BusyBox?
      } catch {
        try {
          ^ps --everyone --full --windows | lines # Cygwin?
        } catch {
          print -e "Error: ps command failed."
          [] # Return empty list on failure
        }
      }
    }
  }

  # Note: Complex Zsh FZF bindings for kill (click-header transformer) are omitted for simplicity.
  # Users can set custom bindings via FZF_DEFAULT_OPTS if needed.
  let kill_post_closure = {|selected_line| _fzf_complete_kill_post_nu $selected_line }

  let fzf_opts = ["-m", "--header-lines=1", "--no-preview", "--wrap", "--color", "fg:dim,nth:regular"]

  _fzf_complete_nu $ps_gen_closure $fzf_opts $kill_post_closure
}


# --- Main FZF Completion Handler (bound to Tab) ---

# This function checks for the trigger and dispatches to the appropriate completer
def fzf_tab_handler [] {
  let trigger: string = $env.FZF_COMPLETION_TRIGGER? | default '**'
  if ($trigger | is-empty) {
      # Handle empty trigger case if needed, maybe trigger on space?
      # For now, assume trigger is non-empty like '**'
      return # Do nothing if trigger is empty
  }

  let current_line = (commandline) # Get the current line buffer as a string
  let cursor_pos = (commandline get-cursor) # Get the record containing cursor info

  # Check if the text *up to the cursor* ends with the trigger
  let line_before_cursor: string = $current_line | str substring 0..<$cursor_pos
  let ends_with_trigger = ($line_before_cursor | str ends-with $trigger)

  if $ends_with_trigger {
    # --- Trigger Found ---

    # Store the line content just before the trigger for context
    let length_without_trigger: int = ($line_before_cursor | str length) - ($trigger | str length)
    let line_without_trigger: string = $line_before_cursor | str substring 0..<$length_without_trigger

    # Identify command word (first word) and the prefix being completed
    let words = ($line_without_trigger | split row ' ')
    let cmd_word = ($words | first | default "")

    # Prefix is the last word segment *before* the trigger.
    # It might be empty if trigger follows a space.
    let prefix = if ($line_without_trigger | str ends-with " ") {
        ""
    } else {
        $words | last | default ""
    }

    # Calculate the start position of the prefix within the original line
    let start_replace_pos = ($line_without_trigger | str length) - ($prefix | str length)
    # The end position of the replacement is the cursor position (end of the trigger)
    let end_replace_pos = $cursor_pos

    # Store prefix for helper functions to use
    $env.FZF_CURRENT_PREFIX = $prefix

    # --- Dispatch to Completer ---
    mut completion_results = [] # Will hold the list of strings from the completer

    # Check for command-specific completers first
    # Use `match` for cleaner dispatching
    match $cmd_word {
        "ssh" | "scp" | "sftp" | "telnet" => { $completion_results = (_fzf_complete_ssh_nu $prefix $line_without_trigger) }
        "export" | "printenv" => { $completion_results = (_fzf_complete_export_nu $prefix) }
        "unset" => { $completion_results = (_fzf_complete_unset_nu $prefix) }
        "unalias" => { $completion_results = (_fzf_complete_unalias_nu $prefix) }
        "kill" => { $completion_results = (_fzf_complete_kill_nu $prefix) }
        "cd" | "pushd" | "rmdir" => { $completion_results = (_fzf_dir_completion_nu $prefix) }
        # Add other command-specific completions here
        _ => {
            # Default to path completion
            $completion_results = (_fzf_path_completion_nu $prefix)
        }
    }

    # --- Insert Completion ---
    if not ($completion_results | is-empty) {
      # Currently, assumes only one completion item is selected and returned.
      # FZF multi-select (-m) handled by path/kill completers returning list.
      # If multiple items are returned, how to insert? For now, take the first.
      let selected_completion = $completion_results | first

      # Add a space after the completion unless it's a directory ending with a slash
      let text_to_insert = if ($selected_completion | str ends-with "/") {
        $selected_completion # Directories already have trailing slash from completer
      } else {
        $selected_completion + " " # Files/others get a space added
      }

      # Construct the new line buffer string:
      # Part before the prefix + selected completion + part after the original cursor
      let part_before_replace = $current_line | str substring 0 $start_replace_pos
      let part_after_replace = $current_line | str substring $cursor_pos
      let new_buffer_string = $part_before_replace + $text_to_insert + $part_after_replace

      # Replace the entire buffer with the new string
      # {{change 1}} - Use commandline edit --replace to replace the whole buffer
      commandline edit --replace $new_buffer_string

      # Calculate and set the new cursor position
      # It should be at the end of the inserted text
      let new_cursor_pos = $start_replace_pos + ($text_to_insert | str length)
      # {{change 2}} - Set the cursor position
      commandline set-cursor $new_cursor_pos
    } else {
      # No completion selected/found. Just remove the trigger.

      # Calculate the start position of the trigger within the original line
      let start_trigger_pos = $cursor_pos - ($trigger | str length)

      # Construct the new line buffer string:
      # Part before the trigger + part after the original cursor
      let part_before_trigger = $current_line | str substring 0..$start_trigger_pos
      let part_after_trigger = $current_line | str substring $cursor_pos..
      let new_buffer_string = $part_before_trigger + $part_after_trigger

      # Replace the entire buffer with the new string
      # {{change 3}} - Use commandline edit --replace to replace the whole buffer
      commandline edit --replace $new_buffer_string

      # Set the cursor position to the end of the text that was before the trigger
      # {{change 4}} - Set the cursor position
      commandline set-cursor $start_trigger_pos
    }

    # Unset temporary prefix env var
    $env.FZF_CURRENT_PREFIX = null

  } else {
    # --- Trigger Not Found ---
    # Execute the default tab completion behavior.
    # WARNING: This is the hard part in Nushell when using `input bind`.
    # `input bind` *replaces* the default binding. There's no standard, stable
    # way to invoke the "original" Tab behavior from within a custom binding.
    # This implementation currently does *nothing* if the trigger isn't found,
    # effectively preventing default completion when this binding is active.
    #
    # Possible workarounds (complex, potentially fragile):
    # 1. Try to replicate Nushell's default completion logic here. (Very difficult)
    # 2. Use `register-completion` instead, but that has different trigger mechanisms.
    # 3. Hope future Nushell versions provide a way to chain or call default bindings.
    #
    # For now, accept that default Tab completion might be disabled.
    return # Explicitly do nothing, allowing potential (but unlikely) fallback.
  }
}

# --- Register the Tab key binding ---

# This replaces the default Tab behavior with our fzf handler.
# See the warning in `fzf_tab_handler` regarding default completion fallback.
export-env {
  # Prevent adding the keybinding multiple times if the script is sourced again
  if not ($env.__fzf_completion_keybinding_loaded? | default false) {
    $env.__fzf_completion_keybinding_loaded = true
    $env.config.keybindings = $env.config.keybindings | append [
      {
        name: fzf_completion # A unique name for this keybinding
        modifier: none # Tab doesn't typically require a modifier
        keycode: Tab # Keycode for the Tab key (confirm with `keybindings list --keycodes` if needed)
        mode: [emacs, vi_normal, vi_insert] # Apply this binding in all common modes
        event: {
          send: executehostcommand # Execute a Nushell command
          cmd: "fzf_tab_handler" # The command to execute
        }
      }
    ]
  }
}

# Optional: Define custom compgen functions if needed, e.g.:
# def _fzf_compgen_path_nu [dir: string] {
#   # Your custom path generation logic here, outputting paths line by line or as a list
#   ls -a $dir | where name != '.' | where name != '..' | get name | each {|name| ($dir | path join $name)}
# }
# Then modify __fzf_generic_path_completion_nu to check for and use these if defined.