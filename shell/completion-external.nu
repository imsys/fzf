#     ____      ____
#    / __/___  / __/
#   / /_/_  / / /_
#  / __/ / /_/ __/
# /_/   /___/_/ completion-external.nu


# Generated by AI, mostly Gemini.

# A different implementation aproach than completion.nu
# docs at
# https://www.nushell.sh/cookbook/external_completers.html

# Translates the core logic of fzf's completion.zsh/bash to Nushell.

# --- Default Environment Variables ---
# These can be overridden in your config.nu or environment.
# Example: $env.FZF_COMPLETION_TRIGGER = "!<TAB>"

# Set default height for fzf-tmux pane. e.g. '40%'
$env.FZF_TMUX_HEIGHT = $env.FZF_TMUX_HEIGHT? | default '40%'
# Options for fzf-tmux wrapper. e.g. '--paneid popup'
$env.FZF_TMUX_OPTS = $env.FZF_TMUX_OPTS? | default ''
# Trigger sequence. e.g. '**'
$env.FZF_COMPLETION_TRIGGER = $env.FZF_COMPLETION_TRIGGER? | default '**'
# Options for fzf completion in general. e.g. '--border'
$env.FZF_COMPLETION_OPTS = $env.FZF_COMPLETION_OPTS? | default ''
# Options specific to path completion. e.g. '--extended'
$env.FZF_COMPLETION_PATH_OPTS = $env.FZF_COMPLETION_PATH_OPTS? | default ''
# Options specific to directory completion. e.g. '--extended'
$env.FZF_COMPLETION_DIR_OPTS = $env.FZF_COMPLETION_DIR_OPTS? | default ''

# --- Helper Functions ---

# Helper to build default fzf options list
def __fzf_defaults_nu [prepend: string, append: string] {
  let default_opts = $env.FZF_DEFAULT_OPTS? | default ''
  let default_opts_file = $env.FZF_DEFAULT_OPTS_FILE? | default ''

  let file_opts = try {
     open $default_opts_file | lines | str trim | where not ($in | is-empty)
  } catch {
     [] # Return empty list on error (e.g., file not found)
  }

  # Build options list
  [$"--height" ($env.FZF_TMUX_HEIGHT? | default '40%') $prepend]
  | append $file_opts # Append options from file
  | append ($default_opts | split words | where not ($in | is-empty)) # Append options from $FZF_DEFAULT_OPTS
  | append ($append | split words | where not ($in | is-empty)) # Append options from function argument
  | where {|it|
      try {
        # Check if it's a string and not empty. If this fails for an item (e.g., error),
        # the catch block handles it.
        ($it | is-string) and not ($it | is-empty)
      } catch {
        # If any error occurred when processing this item (like trying to call is-string on an error),
        # return false to filter it out.
        false
      }
    } # Filter to keep only non-empty strings, safely handling potential errors
}

# Wrapper for running fzf or fzf-tmux
def __fzf_comprun_nu [
  context_name: string, # e.g., "fzf-completion", "fzf-helper" - mainly for potential debugging
  query: string,        # The initial query string for fzf
  ...fzf_opts: string # Remaining options for fzf/fzf-tmux
  ] {
  # Check for custom comprun function (Nu equivalent)
  if ((help commands | where name == '_fzf_comprun_nu') | is-not-empty) {
    # Note: Nushell doesn't have a direct equivalent to Zsh/Bash `type -t _fzf_comprun`.
    # This check assumes a user might define a custom command named `_fzf_comprun_nu`.
    _fzf_comprun_nu $context_name $query ...$fzf_opts # Pass args correctly to custom function
  } else if ($env.TMUX_PANE? | is-not-empty) and (($env.FZF_TMUX? | default 0) != 0 or ($env.FZF_TMUX_OPTS? | is-not-empty)) {
    # Running inside tmux, use fzf-tmux
    # Skip the first arg which is cmd_word (passed for context but not needed by fzf/fzf-tmux itself)
    let final_fzf_opts = ['--query', $query] | append $fzf_opts

    if ($env.FZF_TMUX_OPTS? | is-not-empty) {
      # If FZF_TMUX_OPTS contains multiple options as a single string, split them.
      let tmux_opts_list = $env.FZF_TMUX_OPTS | split words
      fzf-tmux ...$tmux_opts_list -- ...$final_fzf_opts
    } else {
      fzf-tmux -d $env.FZF_TMUX_HEIGHT -- ...$final_fzf_opts
    }
  } else {
    # Not in tmux or not configured for fzf-tmux, use fzf directly
    let final_fzf_opts = ['--query', $query] | append $fzf_opts
    fzf ...$final_fzf_opts
  }
}

# Generate host list for ssh/telnet
def __fzf_list_hosts_nu [] {
  # Translate the Zsh pipeline using Nu commands and external tools
  let ssh_configs = try { open ~/.ssh/config | lines } catch { [] }
  let ssh_configs_d = try { open ~/.ssh/config.d/* | lines } catch { [] }
  let ssh_config_global = try { open /etc/ssh/ssh_config | lines } catch { [] }
  let known_hosts = try { open ~/.ssh/known_hosts | lines } catch { [] }
  let hosts_file = try { open /etc/hosts | lines } catch { [] }

  [
    (
      # Process ssh config files
      $ssh_configs | append $ssh_configs_d | append $ssh_config_global
      | where {|it| ($it | str downcase | str starts-with 'host') or ($it | str downcase | str starts-with 'hostname') }
      | parse --regex '^\s*host(?:name)?\s+(?<hosts>.+)' # Extract hosts after keyword
      | default { hosts: null } # Handle lines that don't match regex
      | get hosts
      | where $in != null
      | split words
      | where not ($in =~ '[*?%]') # Exclude patterns containing *, ?, or %
    )
    (
      # Process known_hosts file
      $known_hosts
      | parse --regex '^(?:\[)?(?<hosts>[a-z0-9.,:_-]+)' # Extract hostnames (possibly in [], possibly comma-separated) - added underscore
      | default { hosts: null }
      | get hosts
      | where $in != null
      | each { |it| $it | split row ',' } # Split comma-separated hosts if any
      | flatten
    )
    (
      # Process /etc/hosts file
      $hosts_file
      | where { |it| not ($it | str starts-with '#') } # Ignore comments
      | where { |it| not ($it | str trim | is-empty) } # Ignore empty lines
      | where { |it| not ($it | str contains '0.0.0.0') } # Ignore 0.0.0.0
      | str replace --regex '#.*$' '' # Remove trailing comments
      | parse --regex '^\s*\S+\s+(?<hosts>.+)' # Extract hosts part (after IP)
      | default { hosts: null }
      | get hosts
      | where $in != null
      | split words # Split multiple hosts on the same line
    )
  ]
  | flatten # Combine all lists into a single stream
  | where not ($in | is-empty) # Remove empty entries
  | sort | uniq # Sort and remove duplicates
}


# Base function for path/directory completion
def __fzf_generic_path_completion_nu [
    prefix: string,           # The text before the trigger
    compgen_cmd_name: string,        # Optional custom generator block `{|dir| ... }`
    fzf_opts_nu: list<string>, # Extra options for fzf
    suffix: string,           # Suffix to add to selection (e.g., "/")
    _tail: string             # Trailing chars (e.g., space, often handled by insertion logic now)
] {
  let base = $prefix
  # Note: Zsh `eval "base=$base"` handles complex expansions like `$(...)`.
  # Nushell doesn't evaluate arbitrary strings in the same way. We assume `prefix`
  # We assume `prefix` is a simple path prefix. Expand leading ~ if present.
  let base_expanded: string = $base | path expand --no-symlink # Expand ~ but don't resolve symlinks yet

  # Determine the directory to search within
  let dir: string = if ($base_expanded | path type) == 'dir' {
    $base_expanded
  } else if ($base_expanded | str contains (char separator)) { # Use platform separator
    $base_expanded | path dirname
  } else {
     '.'
  }

  # Find the deepest existing directory part of the path to use as root for find/ls
  let root_dir = $dir
  # Use path expand to normalize and handle .., ., etc.
  let root_dir_expanded: string = $dir | path expand # Resolve fully now, including symlinks by default

  # Simplified logic: Use the determined 'dir'. Zsh has a loop to find existing parents.
  # Nushell's `find` or `ls` might handle non-existent paths gracefully or error.
  # Let's try with the derived dir, using path expand for clarity.


  # Calculate leftover part (what the user typed after the last slash)
  let leftover = if $root_dir == '.' {
    $base # If base didn't contain '/', leftover is the whole base
  } else {
    # Ensure root_dir_expanded has a trailing slash for correct replacement
    let root_to_replace: string = if ($root_dir_expanded | str ends-with (char separator)) { $root_dir_expanded } else { $"($root_dir_expanded)(char separator)" }
    # Use the ~ expanded base for replacement
    $base_expanded | str replace $root_to_replace ''
  }

  # --- Candidate Generation ---
  # Use the custom generator if provided, otherwise use external `find`.
  let generation_result = if not ($compgen_cmd_name | is-empty) {
    # Construct the command call as a list and execute using the spread operator
    let command_call = [$compgen_cmd_name, $root_dir_expanded]
    let custom_candidates = try {
        ...$command_call # Execute the command with its argument
    } catch {
        print -e $"Error executing custom compgen command '($compgen_cmd_name)' with arg '($root_dir_expanded)'"
        [] # Return empty list on error
    }
    { candidates: $custom_candidates, use_walker: false } # Return record
  } else {
    { candidates: [], use_walker: true } # Return record
  }

  let candidates = $generation_result.candidates
  let use_walker: bool = $generation_result.use_walker

  # --- Run FZF ---
  let fzf_default_opts = (__fzf_defaults_nu "--reverse --scheme=path" ($env.FZF_COMPLETION_OPTS | default ''))
  # Add completion-type specific options
  let completion_type_opts = if $suffix == '/' {
      $env.FZF_COMPLETION_DIR_OPTS? | default '' | split words
  } else {
      $env.FZF_COMPLETION_PATH_OPTS? | default '' | split words
  }

  mut fzf_all_opts = $fzf_default_opts | append $fzf_opts_nu | append $completion_type_opts

  # If using the walker, add walker options
  if $use_walker {
    let walker_type = if ($suffix == '/') {
        # Directory completion: find only directories, follow links
        "dir,follow"
    } else {
        # Path completion: find files, dirs, links, follow links, include hidden
        "file,dir,follow,hidden"
    }
    # Add walker options
    $fzf_all_opts = $fzf_all_opts | append ["--walker", $walker_type, "--walker-root", $root_dir_expanded]
  }

  # Pipe candidates (if any) to fzf or let fzf use its walker
  let fzf_selection = if $use_walker {
      # No input pipe, fzf uses walker
      __fzf_comprun_nu "fzf-path-completion-walker" $leftover ...$fzf_all_opts
  } else {
      # Pipe custom candidates
      $candidates | __fzf_comprun_nu "fzf-path-completion-custom" $leftover ...$fzf_all_opts
  } | str trim # fzf output often has trailing newline

  # --- Format Selection ---
  let completed_item = if ($fzf_selection | is-not-empty) {
      # Add suffix (e.g., "/" for directories)
      $fzf_selection + $suffix
  } else {
      "" # No selection
  }

  # --- Return Result ---
  # Nushell completers return a list of completion strings.
  if ($completed_item | is-not-empty) {
     [$completed_item] # Return selection as a list containing one item
  } else {
     [] # Return empty list if no selection
  }
}

# Specific path completion wrapper
def _fzf_path_completion_nu [prefix: string] {
  # Zsh args: base, lbuf, _fzf_compgen_path, "-m", "", " "
  # Nu: prefix, empty command name (use find), ["-m"], "", " "
  __fzf_generic_path_completion_nu $prefix "" ["-m"] "" " "
}

# Specific directory completion wrapper
def _fzf_dir_completion_nu [prefix: string] {
  # Zsh args: base, lbuf, _fzf_compgen_dir, "", "/", ""
  # Nu: prefix, empty command name (use find), [], "/", ""
  __fzf_generic_path_completion_nu $prefix "" [] "/" ""
}

# General completion helper for commands that feed a list to fzf
def _fzf_complete_nu [
    prefix: string,              # The current prefix before the trigger
    data_gen_closure: closure,    # Closure that generates candidates
    fzf_opts: list<string>,  # Extra options for fzf (like -m, +m)
    post_process_closure: closure # Closure to process the selected item (optional)
] {
  # Build fzf default options list
  let fzf_default_opts = (__fzf_defaults_nu "--reverse" ($env.FZF_COMPLETION_OPTS | default ''))

  # Generate candidates using the provided command
  let candidates = try {
    do $data_gen_closure
  } catch {
    print -e $"Error executing data_gen closure: ($data_gen_closure)"
    []
  }

  # Run fzf and get selection
  let fzf_selection = $candidates
  | __fzf_comprun_nu "fzf-helper" $prefix ...$fzf_default_opts ...$fzf_opts # Pass context name, query, and options
  | str trim # Trim potential trailing newline from fzf

  # Apply post-processing if closure provided and selection is not empty
  let processed_selection = if ($fzf_selection | is-not-empty) and ($post_process_closure != null) {
    # Call the post-processing closure with the selection
    try {
      do $post_process_closure $fzf_selection
    } catch {
      print -e $"Error executing post_process closure: ($post_process_closure)"
      $fzf_selection # Return original selection on error
    }
  } else {
    $fzf_selection
  }

  if not ($processed_selection | is-empty) {
    [$processed_selection] # Return as list
  } else {
    []
  }
}

# SSH/Telnet completion
def _fzf_complete_ssh_nu [prefix: string, input_line_before_trigger: string] {
  let words = ($input_line_before_trigger | split words)
  let word_count = $words | length

  # Find the index of the word being completed (which is the prefix)
  # If prefix is empty, completion happens after a space, index is word_count
  # If prefix is not empty, it's the last word, index is word_count - 1
  let completion_index = if ($prefix | is-empty) { $word_count } else { $word_count - 1 }

  mut handled = false
  mut completion_result = [] # List of completion strings to return

  # Check for -i, -F, -E flags immediately preceding the cursor position
  if $completion_index > 0 {
    let prev_arg = ($words | get ($completion_index - 1))
    if ($prev_arg in ['-i', '-F', '-E']) {
      $handled = true
      # Call path completion with the current prefix
      $completion_result = (_fzf_path_completion_nu $prefix)
    }
  }

  # If not handled by path completion, do host completion
  if not $handled {
    let user_part = if ($prefix | str contains "@") { ($prefix | split column "@" | first) + "@" } else { "" }
    # The part after '@' (or the whole prefix if no '@') is the initial query for fzf
    let host_prefix = if ($prefix | str contains "@") { $prefix | split column "@" | get 1 } else { $prefix }

    let host_candidates_gen = {||
      __fzf_list_hosts_nu
      | each {|host_item| $user_part + $host_item } # Prepend user@ if present in prefix
    }

    # Zsh options: +m -- ; Nu: pass ["+m"]
    # Pass the host part of the prefix to _fzf_complete_nu for the initial query
    let selected_host = (_fzf_complete_nu $host_prefix $host_candidates_gen ["+m"] {}) # Pass host_prefix here
    if not ($selected_host | is-empty) {
      $completion_result = $selected_host # _fzf_complete_nu returns a list
    }
  }

  $completion_result
}

# Export completion
def _fzf_complete_export_nu [prefix: string] {
  let vars_gen_closure = {|| env | get name } # Nushell `env` provides names directly
  # Zsh options: -m -- ; Nu: pass ["-m"]
  _fzf_complete_nu $prefix $vars_gen_closure ["-m"] {} # Pass prefix
}

# Unset completion (same as export)
def _fzf_complete_unset_nu [prefix: string] {
  _fzf_complete_export_nu $prefix # Re-use export logic (already passes prefix)
}

# Unalias completion
def _fzf_complete_unalias_nu [prefix: string] {
  let aliases_gen_closure = {|| aliases | get alias } # Use 'alias' column from `aliases` command
  # Zsh options: +m -- ; Nu: pass ["+m"]
  _fzf_complete_nu $prefix $aliases_gen_closure ["+m"] {} # Pass prefix
}

# Kill completion post-processor (extracts PID)
def _fzf_complete_kill_post_nu [selected_line: string] {
  # Assuming standard ps output where PID is the second column
  $selected_line | split words | get 1 | default ""
}

# Kill completion
def _fzf_complete_kill_nu [prefix: string] {
  let ps_gen_closure = {|| # Define ps generator as a closure
    # Try standard ps, then busybox, then cygwin format approximation
    # Use `^ps` to ensure external command execution
    try {
      ^ps -eo user,pid,ppid,start,time,command | lines # Keep header for --header-lines=1
    } catch {
      try {
        ^ps -eo user,pid,ppid,time,args | lines # BusyBox?
      } catch {
        try {
          ^ps --everyone --full --windows | lines # Cygwin?
        } catch {
          print -e "Error: ps command failed."
          [] # Return empty list on failure
        }
      }
    }
  }

  # Note: Complex Zsh FZF bindings for kill (click-header transformer) are omitted for simplicity.
  # Users can set custom bindings via FZF_DEFAULT_OPTS if needed.
  let kill_post_closure = {|selected_line| _fzf_complete_kill_post_nu $selected_line }

  let fzf_opts = ["-m", "--header-lines=1", "--no-preview", "--wrap", "--color", "fg:dim,nth:regular"]

  _fzf_complete_nu $prefix $ps_gen_closure $fzf_opts $kill_post_closure # Pass prefix
}


# --- Main FZF External Completer ---

# This function is registered with Nushell's external completion system.
# It gets called when Tab is pressed.
let fzf_external_completer = {|spans|
    let trigger: string = $env.FZF_COMPLETION_TRIGGER? | default '**'

    if ($trigger | is-empty) { return null } # Cannot work with empty trigger
    if (($spans | length ) == 0) { return null } # Nothing to complete

    let last_span = $spans | last
    let line_so_far = $spans | str join ' ' # Reconstruct line for context

    # Check if the last span (the word being completed) ends with the trigger
    if ($last_span | str ends-with $trigger) {
        # --- Trigger Found ---

        # Calculate the prefix (part before the trigger in the last span)
        let prefix = $last_span | str substring 0..(-1 * ($trigger | str length) - 1)

        # Determine command word (first word on the line)
        let cmd_word = if (($spans | length ) > 1) {
            $spans.0 # Usually the first span
        } else if not ($prefix | is-empty) {
             # If only one span and it contains prefix + trigger, it might be the command
             "" # Treat as generic path completion if command itself has trigger
        } else {
            "" # No command word yet
        }

        #return [$cmd_word, $prefix]

        # Reconstruct the line content *before* the trigger for context
        # This is an approximation based on spans
        let line_without_trigger_approx = $spans | take (($spans | length) - 1) | append $prefix | str join ' '

        # --- Dispatch to Completer ---
        mut completion_results = [] # Will hold the list of strings from the completer

        match $cmd_word {
            "ssh" | "scp" | "sftp" | "telnet" => { $completion_results = (_fzf_complete_ssh_nu $prefix $line_without_trigger_approx) }
            "export" | "printenv" => { $completion_results = (_fzf_complete_export_nu $prefix) }
            "unset" => { $completion_results = (_fzf_complete_unset_nu $prefix) }
            "unalias" => { $completion_results = (_fzf_complete_unalias_nu $prefix) }
            "kill" => { $completion_results = (_fzf_complete_kill_nu $prefix) }
            "cd" | "pushd" | "rmdir" => { $completion_results = (_fzf_dir_completion_nu $prefix) }
            # Add other command-specific completions here
            _ => {
                # Default to path completion if no specific command matches or cmd_word is empty
                $completion_results = (_fzf_path_completion_nu $prefix)
            }
        }

        # --- Return Results ---
        # The _fzf_... functions return a list of completion strings.
        # Nushell's completer expects the suggestions for the token being completed (prefix + trigger).
        # The results from the helper functions should be the final desired strings.
        # We don't need to manually add spaces; Nushell handles that.
        $completion_results # Return the list directly
    } else {
        # --- Trigger Not Found ---
        # Return null to let Nushell fall back to other completers (e.g., default file completion).
        null
    }
}

# --- WRAPPER AND REGISTRATION ---

# Get the currently configured external completer, if any exists
let previous_external_completer = $env.config? | get completions? | get external? | get completer?

# Define the new wrapper completer
let fzf_wrapper_completer = {|spans|
    # 1. Try the FZF completer logic first
    let fzf_result = do $fzf_external_completer $spans

    # 2. If FZF returned a result (a list, even an empty one), return it.
    #    `null` means FZF didn't handle it because the trigger wasn't present.
    if $fzf_result != null {
        # print "DEBUG: FZF Wrapper returning FZF result." # Debug
        $fzf_result
    } else {
        # 3. FZF didn't handle it, so call the previous completer (if it exists).
        if $previous_external_completer != null {
            # print "DEBUG: FZF Wrapper calling previous completer." # Debug
            do $previous_external_completer $spans
        } else {
            # 4. No previous completer, and FZF didn't handle it. Return null.
            # print "DEBUG: FZF Wrapper returning null (no previous completer)." # Debug
            null
        }
    }
}

# Register the new wrapper completer
# This ensures external completions are enabled and sets our wrapper.
$env.config = $env.config | upsert completions {
  external: {
    enable: true
    completer: $fzf_wrapper_completer
  }
}

# Optional: Define custom compgen functions if needed, e.g.:
# def _fzf_compgen_path_nu [dir: string] {
#   # Your custom path generation logic here, outputting paths line by line or as a list
#   ls -a $dir | where name != '.' | where name != '..' | get name | each {|name| ($dir | path join $name)}
# }
# Then modify __fzf_generic_path_completion_nu to check for and use these if defined.